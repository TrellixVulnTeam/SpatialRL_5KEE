// Generated by SpatialOS codegen. DO NOT EDIT!
// source: improbable/standard_library.schema
#ifndef SPATIALOS_SCHEMA_improbable_standard_library_schema_15375418286384799311_INCLUDED
#define SPATIALOS_SCHEMA_improbable_standard_library_schema_15375418286384799311_INCLUDED
#include <improbable/collections.h>
#include <improbable/math/coordinates.h>
#include <improbable/math/vector3d.h>
#include <improbable/math/vector3f.h>
#include <improbable/worker.h>
#include <cstddef>
#include <cstdint>
#include <set>
#include <string>

// Schema forward declarations.
//----------------------------------------------------------------

namespace schema {
namespace improbable {

class WorkerClaimAtom;
class WorkerClaim;
class WorkerPredicate;
class ComponentAcl;
class EntityAclData;

}  // ::improbable
}  // ::schema

namespace improbable {

// Forward declarations.
//----------------------------------------------------------------

class ComponentAcl;
class EntityAclData;
class WorkerClaim;
class WorkerClaimAtom;
class WorkerPredicate;

namespace detail {
const ::worker::detail::ClientComponentVtable& Vtable_EntityAcl();
struct GenericCommandObject_EntityAcl {
  std::uint32_t CommandId;
  ::worker::Variant<> CommandObject;
};
}  // ::detail

// Enumerations.
//----------------------------------------------------------------

// Data classes.
//----------------------------------------------------------------

class ComponentAcl {
public:
  // Main constructor.
  ComponentAcl(const ::worker::Map< std::uint32_t, ::improbable::WorkerPredicate >& write);

  // Copyable and moveable.
  ComponentAcl(ComponentAcl&&) = default;
  ComponentAcl(const ComponentAcl&) = default;
  ComponentAcl& operator=(ComponentAcl&&) = default;
  ComponentAcl& operator=(const ComponentAcl&) = default;
  ~ComponentAcl() = default;

  bool operator==(const ComponentAcl&) const;
  bool operator!=(const ComponentAcl&) const;

  // Field write = 1.
  const ::worker::Map< std::uint32_t, ::improbable::WorkerPredicate >& write() const;
  ::worker::Map< std::uint32_t, ::improbable::WorkerPredicate >& write();
  ComponentAcl& set_write(const ::worker::Map< std::uint32_t, ::improbable::WorkerPredicate >&);

private:
  ::worker::Map< std::uint32_t, ::improbable::WorkerPredicate > _write;
};

class EntityAclData {
public:
  // Main constructor.
  EntityAclData(
      const ::worker::Option< ::improbable::WorkerPredicate >& read,
      const ::worker::Option< ::improbable::ComponentAcl >& component_acl);

  // Copyable and moveable.
  EntityAclData(EntityAclData&&) = default;
  EntityAclData(const EntityAclData&) = default;
  EntityAclData& operator=(EntityAclData&&) = default;
  EntityAclData& operator=(const EntityAclData&) = default;
  ~EntityAclData() = default;

  bool operator==(const EntityAclData&) const;
  bool operator!=(const EntityAclData&) const;

  // Field read = 1.
  const ::worker::Option< ::improbable::WorkerPredicate >& read() const;
  ::worker::Option< ::improbable::WorkerPredicate >& read();
  EntityAclData& set_read(const ::worker::Option< ::improbable::WorkerPredicate >&);

  // Field component_acl = 2.
  const ::worker::Option< ::improbable::ComponentAcl >& component_acl() const;
  ::worker::Option< ::improbable::ComponentAcl >& component_acl();
  EntityAclData& set_component_acl(const ::worker::Option< ::improbable::ComponentAcl >&);

private:
  ::worker::Option< ::improbable::WorkerPredicate > _read;
  ::worker::Option< ::improbable::ComponentAcl > _component_acl;
};

class WorkerClaim {
public:
  // Main constructor.
  WorkerClaim(const ::worker::List< ::improbable::WorkerClaimAtom >& atom);

  // Copyable and moveable.
  WorkerClaim(WorkerClaim&&) = default;
  WorkerClaim(const WorkerClaim&) = default;
  WorkerClaim& operator=(WorkerClaim&&) = default;
  WorkerClaim& operator=(const WorkerClaim&) = default;
  ~WorkerClaim() = default;

  bool operator==(const WorkerClaim&) const;
  bool operator!=(const WorkerClaim&) const;

  // Field atom = 1.
  const ::worker::List< ::improbable::WorkerClaimAtom >& atom() const;
  ::worker::List< ::improbable::WorkerClaimAtom >& atom();
  WorkerClaim& set_atom(const ::worker::List< ::improbable::WorkerClaimAtom >&);

private:
  ::worker::List< ::improbable::WorkerClaimAtom > _atom;
};

class WorkerClaimAtom {
public:
  // Main constructor.
  WorkerClaimAtom(const ::worker::Option< std::string >& name);

  // Copyable and moveable.
  WorkerClaimAtom(WorkerClaimAtom&&) = default;
  WorkerClaimAtom(const WorkerClaimAtom&) = default;
  WorkerClaimAtom& operator=(WorkerClaimAtom&&) = default;
  WorkerClaimAtom& operator=(const WorkerClaimAtom&) = default;
  ~WorkerClaimAtom() = default;

  bool operator==(const WorkerClaimAtom&) const;
  bool operator!=(const WorkerClaimAtom&) const;

  // Field name = 1.
  const ::worker::Option< std::string >& name() const;
  ::worker::Option< std::string >& name();
  WorkerClaimAtom& set_name(const ::worker::Option< std::string >&);

private:
  ::worker::Option< std::string > _name;
};

class WorkerPredicate {
public:
  // Main constructor.
  WorkerPredicate(const ::worker::List< ::improbable::WorkerClaim >& claim);

  // Copyable and moveable.
  WorkerPredicate(WorkerPredicate&&) = default;
  WorkerPredicate(const WorkerPredicate&) = default;
  WorkerPredicate& operator=(WorkerPredicate&&) = default;
  WorkerPredicate& operator=(const WorkerPredicate&) = default;
  ~WorkerPredicate() = default;

  bool operator==(const WorkerPredicate&) const;
  bool operator!=(const WorkerPredicate&) const;

  // Field claim = 1.
  const ::worker::List< ::improbable::WorkerClaim >& claim() const;
  ::worker::List< ::improbable::WorkerClaim >& claim();
  WorkerPredicate& set_claim(const ::worker::List< ::improbable::WorkerClaim >&);

private:
  ::worker::List< ::improbable::WorkerClaim > _claim;
};

// Component metaclasses and update classes.
//----------------------------------------------------------------

/**
 * This type can be supplied as the template parameter to all component-related templated types
 * and methods in the C++ worker API. For example:
 *
 *   using ::improbable::EntityAcl;
 *
 *   EntityAcl::Update update;
 *   connection.SendComponentUpdate< EntityAcl >(entity_id, update);
 *
 *   dispatcher.OnComponentUpdate< EntityAcl >(
 *       [&](const worker::ComponentUpdateOp< EntityAcl >& op) {
 *         worker::EntityId entity_id = op.GetEntityId();
 *         EntityAcl::Update update = op.GetUpdate();
 *       });
 *
 *   EntityAcl::Data data = entity.Get< EntityAcl >();
 */
struct EntityAcl : ::worker::detail::ComponentMetaclassBase<
    EntityAcl, detail::Vtable_EntityAcl> {
  static constexpr const ::worker::ComponentId ComponentId = 50;
  using Data = ::improbable::EntityAclData;
  using GenericCommandObject = detail::GenericCommandObject_EntityAcl;

  class Update {
  public:
    // Default-constructible, copyable and movable.
    Update() = default;
    Update(Update&&) = default;
    Update(const Update&) = default;
    Update& operator=(Update&&) = default;
    Update& operator=(const Update&) = default;
    ~Update() = default;

    bool operator==(const Update&) const;
    bool operator!=(const Update&) const;

    /** Creates an Update from a ::improbable::EntityAclData object. */
    static Update FromInitialData(const ::improbable::EntityAclData& data);

    /**
     * Converts to a ::improbable::EntityAclData
     * object. It is an error to call this function unless *all* of the optional fields in this
     * update are filled in.
     */
    ::improbable::EntityAclData ToInitialData() const;

    /**
     * Replaces fields in the given ::improbable::EntityAclData
     * object with the corresponding fields in this update, where present.
     */
    void ApplyTo(::improbable::EntityAclData&) const;

    // Field read = 1.
    const ::worker::Option< ::worker::Option< ::improbable::WorkerPredicate > >& read() const;
    ::worker::Option< ::worker::Option< ::improbable::WorkerPredicate > >& read();
    Update& set_read(const ::worker::Option< ::improbable::WorkerPredicate >&);

    // Field component_acl = 2.
    const ::worker::Option< ::worker::Option< ::improbable::ComponentAcl > >& component_acl() const;
    ::worker::Option< ::worker::Option< ::improbable::ComponentAcl > >& component_acl();
    Update& set_component_acl(const ::worker::Option< ::improbable::ComponentAcl >&);

  private:
    ::worker::Option< ::worker::Option< ::improbable::WorkerPredicate > > _read;
    ::worker::Option< ::worker::Option< ::improbable::ComponentAcl > > _component_acl;
  };

};

// Implementation details.
//----------------------------------------------------------------

namespace detail {

void Serialize_ComponentAcl(
    const ::improbable::ComponentAcl&,
    ::schema::improbable::ComponentAcl&);

::improbable::ComponentAcl Deserialize_ComponentAcl(
    const ::schema::improbable::ComponentAcl&);

void Serialize_EntityAclData(
    const ::improbable::EntityAclData&,
    ::schema::improbable::EntityAclData&);

::improbable::EntityAclData Deserialize_EntityAclData(
    const ::schema::improbable::EntityAclData&);

void Serialize_WorkerClaim(
    const ::improbable::WorkerClaim&,
    ::schema::improbable::WorkerClaim&);

::improbable::WorkerClaim Deserialize_WorkerClaim(
    const ::schema::improbable::WorkerClaim&);

void Serialize_WorkerClaimAtom(
    const ::improbable::WorkerClaimAtom&,
    ::schema::improbable::WorkerClaimAtom&);

::improbable::WorkerClaimAtom Deserialize_WorkerClaimAtom(
    const ::schema::improbable::WorkerClaimAtom&);

void Serialize_WorkerPredicate(
    const ::improbable::WorkerPredicate&,
    ::schema::improbable::WorkerPredicate&);

::improbable::WorkerPredicate Deserialize_WorkerPredicate(
    const ::schema::improbable::WorkerPredicate&);

}  // ::detail
}  // ::improbable

#endif  // SPATIALOS_SCHEMA_improbable_standard_library_schema_15375418286384799311_INCLUDED
