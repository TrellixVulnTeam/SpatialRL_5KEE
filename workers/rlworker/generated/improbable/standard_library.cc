// Generated by SpatialOS codegen. DO NOT EDIT!
// source: improbable/standard_library.schema
#include <improbable/standard_library.h>
#include <improbable/entity_state.pb.h>
#include <improbable/standard_library.pb.h>

namespace improbable {

// Implementation of ComponentAcl.
//----------------------------------------------------------------

ComponentAcl::ComponentAcl(const ::worker::Map< std::uint32_t, ::improbable::WorkerPredicate >& write)
: _write{write} {}

bool ComponentAcl::operator==(const ComponentAcl& value) const {
  return
      _write == value._write;
}

bool ComponentAcl::operator!=(const ComponentAcl& value) const {
  return !operator==(value);
}

const ::worker::Map< std::uint32_t, ::improbable::WorkerPredicate >& ComponentAcl::write() const {
  return _write;
}

::worker::Map< std::uint32_t, ::improbable::WorkerPredicate >& ComponentAcl::write() {
  return _write;
}

ComponentAcl& ComponentAcl::set_write(const ::worker::Map< std::uint32_t, ::improbable::WorkerPredicate >& value) {
  _write = value;
  return *this;
}

// Implementation of EntityAclData.
//----------------------------------------------------------------

EntityAclData::EntityAclData(
    const ::worker::Option< ::improbable::WorkerPredicate >& read,
    const ::worker::Option< ::improbable::ComponentAcl >& component_acl)
: _read{read}
, _component_acl{component_acl} {}

bool EntityAclData::operator==(const EntityAclData& value) const {
  return
      _read == value._read &&
      _component_acl == value._component_acl;
}

bool EntityAclData::operator!=(const EntityAclData& value) const {
  return !operator==(value);
}

const ::worker::Option< ::improbable::WorkerPredicate >& EntityAclData::read() const {
  return _read;
}

::worker::Option< ::improbable::WorkerPredicate >& EntityAclData::read() {
  return _read;
}

EntityAclData& EntityAclData::set_read(const ::worker::Option< ::improbable::WorkerPredicate >& value) {
  _read = value;
  return *this;
}

const ::worker::Option< ::improbable::ComponentAcl >& EntityAclData::component_acl() const {
  return _component_acl;
}

::worker::Option< ::improbable::ComponentAcl >& EntityAclData::component_acl() {
  return _component_acl;
}

EntityAclData& EntityAclData::set_component_acl(const ::worker::Option< ::improbable::ComponentAcl >& value) {
  _component_acl = value;
  return *this;
}

// Implementation of WorkerClaim.
//----------------------------------------------------------------

WorkerClaim::WorkerClaim(const ::worker::List< ::improbable::WorkerClaimAtom >& atom)
: _atom{atom} {}

bool WorkerClaim::operator==(const WorkerClaim& value) const {
  return
      _atom == value._atom;
}

bool WorkerClaim::operator!=(const WorkerClaim& value) const {
  return !operator==(value);
}

const ::worker::List< ::improbable::WorkerClaimAtom >& WorkerClaim::atom() const {
  return _atom;
}

::worker::List< ::improbable::WorkerClaimAtom >& WorkerClaim::atom() {
  return _atom;
}

WorkerClaim& WorkerClaim::set_atom(const ::worker::List< ::improbable::WorkerClaimAtom >& value) {
  _atom = value;
  return *this;
}

// Implementation of WorkerClaimAtom.
//----------------------------------------------------------------

WorkerClaimAtom::WorkerClaimAtom(const ::worker::Option< std::string >& name)
: _name{name} {}

bool WorkerClaimAtom::operator==(const WorkerClaimAtom& value) const {
  return
      _name == value._name;
}

bool WorkerClaimAtom::operator!=(const WorkerClaimAtom& value) const {
  return !operator==(value);
}

const ::worker::Option< std::string >& WorkerClaimAtom::name() const {
  return _name;
}

::worker::Option< std::string >& WorkerClaimAtom::name() {
  return _name;
}

WorkerClaimAtom& WorkerClaimAtom::set_name(const ::worker::Option< std::string >& value) {
  _name = value;
  return *this;
}

// Implementation of WorkerPredicate.
//----------------------------------------------------------------

WorkerPredicate::WorkerPredicate(const ::worker::List< ::improbable::WorkerClaim >& claim)
: _claim{claim} {}

bool WorkerPredicate::operator==(const WorkerPredicate& value) const {
  return
      _claim == value._claim;
}

bool WorkerPredicate::operator!=(const WorkerPredicate& value) const {
  return !operator==(value);
}

const ::worker::List< ::improbable::WorkerClaim >& WorkerPredicate::claim() const {
  return _claim;
}

::worker::List< ::improbable::WorkerClaim >& WorkerPredicate::claim() {
  return _claim;
}

WorkerPredicate& WorkerPredicate::set_claim(const ::worker::List< ::improbable::WorkerClaim >& value) {
  _claim = value;
  return *this;
}

// Implementation of EntityAcl.
//----------------------------------------------------------------

constexpr const ::worker::ComponentId EntityAcl::ComponentId;

bool EntityAcl::Update::operator==(const EntityAcl::Update& value) const {
  return
      _read == value._read &&
      _component_acl == value._component_acl;
}

bool EntityAcl::Update::operator!=(const EntityAcl::Update& value) const {
  return !operator==(value);
}

EntityAcl::Update EntityAcl::Update::FromInitialData(const ::improbable::EntityAclData& data) {
  EntityAcl::Update update;
  update._read.emplace(data.read());
  update._component_acl.emplace(data.component_acl());
  return update;
}

::improbable::EntityAclData EntityAcl::Update::ToInitialData() const {
  return ::improbable::EntityAclData(
      *_read,
      *_component_acl);
}

void EntityAcl::Update::ApplyTo(::improbable::EntityAclData& data) const {
  if (_read) {
    data.set_read(*_read);
  }
  if (_component_acl) {
    data.set_component_acl(*_component_acl);
  }
}

const ::worker::Option< ::worker::Option< ::improbable::WorkerPredicate > >& EntityAcl::Update::read() const {
  return _read;
}

::worker::Option< ::worker::Option< ::improbable::WorkerPredicate > >& EntityAcl::Update::read() {
  return _read;
}

EntityAcl::Update& EntityAcl::Update::set_read(const ::worker::Option< ::improbable::WorkerPredicate >& value) {
  _read.emplace(value); return *this;
}

const ::worker::Option< ::worker::Option< ::improbable::ComponentAcl > >& EntityAcl::Update::component_acl() const {
  return _component_acl;
}

::worker::Option< ::worker::Option< ::improbable::ComponentAcl > >& EntityAcl::Update::component_acl() {
  return _component_acl;
}

EntityAcl::Update& EntityAcl::Update::set_component_acl(const ::worker::Option< ::improbable::ComponentAcl >& value) {
  _component_acl.emplace(value); return *this;
}

// Serialization helpers.
//----------------------------------------------------------------

namespace detail {

void Serialize_ComponentAcl(
    const ::improbable::ComponentAcl& data,
    ::schema::improbable::ComponentAcl& proto) {
  for (const auto& item : data.write()) {
    ::improbable::detail::Serialize_WorkerPredicate(item.second, (*proto.mutable_field1_write())[item.first]);
  }
}

::improbable::ComponentAcl Deserialize_ComponentAcl(
    const ::schema::improbable::ComponentAcl& proto) {
  ::improbable::ComponentAcl result{
      {}};
  for (const auto& item : proto.field1_write()) {
    result.write().emplace(item.first, ::improbable::detail::Deserialize_WorkerPredicate(item.second));
  }
  return result;
}

void Serialize_EntityAclData(
    const ::improbable::EntityAclData& data,
    ::schema::improbable::EntityAclData& proto) {
  if (data.read()) {
    ::improbable::detail::Serialize_WorkerPredicate(*data.read(), *proto.mutable_field1_read());
  }
  if (data.component_acl()) {
    ::improbable::detail::Serialize_ComponentAcl(*data.component_acl(), *proto.mutable_field2_component_acl());
  }
}

::improbable::EntityAclData Deserialize_EntityAclData(
    const ::schema::improbable::EntityAclData& proto) {
  ::improbable::EntityAclData result{
      {},
      {}};
  if (proto.has_field1_read()) {
    result.read().emplace(::improbable::detail::Deserialize_WorkerPredicate(proto.field1_read()));
  }
  if (proto.has_field2_component_acl()) {
    result.component_acl().emplace(::improbable::detail::Deserialize_ComponentAcl(proto.field2_component_acl()));
  }
  return result;
}

void Serialize_WorkerClaim(
    const ::improbable::WorkerClaim& data,
    ::schema::improbable::WorkerClaim& proto) {
  for (const auto& item : data.atom()) {
    ::improbable::detail::Serialize_WorkerClaimAtom(item, *proto.add_field1_atom());
  }
}

::improbable::WorkerClaim Deserialize_WorkerClaim(
    const ::schema::improbable::WorkerClaim& proto) {
  ::improbable::WorkerClaim result{
      {}};
  for (const auto& item : proto.field1_atom()) {
    result.atom().emplace_back(::improbable::detail::Deserialize_WorkerClaimAtom(item));
  }
  return result;
}

void Serialize_WorkerClaimAtom(
    const ::improbable::WorkerClaimAtom& data,
    ::schema::improbable::WorkerClaimAtom& proto) {
  if (data.name()) {
    proto.set_field1_name(*data.name());
  }
}

::improbable::WorkerClaimAtom Deserialize_WorkerClaimAtom(
    const ::schema::improbable::WorkerClaimAtom& proto) {
  ::improbable::WorkerClaimAtom result{
      {}};
  if (proto.has_field1_name()) {
    result.name().emplace(proto.field1_name());
  }
  return result;
}

void Serialize_WorkerPredicate(
    const ::improbable::WorkerPredicate& data,
    ::schema::improbable::WorkerPredicate& proto) {
  for (const auto& item : data.claim()) {
    ::improbable::detail::Serialize_WorkerClaim(item, *proto.add_field1_claim());
  }
}

::improbable::WorkerPredicate Deserialize_WorkerPredicate(
    const ::schema::improbable::WorkerPredicate& proto) {
  ::improbable::WorkerPredicate result{
      {}};
  for (const auto& item : proto.field1_claim()) {
    result.claim().emplace_back(::improbable::detail::Deserialize_WorkerClaim(item));
  }
  return result;
}

namespace {

void VtableBufferFree_EntityAcl(::worker::ComponentId, std::uint8_t* buffer) {
  delete[] buffer;
}

void VtableFree_EntityAcl(
    ::worker::ComponentId, std::uint8_t object_type,
    ::worker::detail::ClientObject* object) {
  if (object_type == ::worker::detail::ClientComponentVtable::Update ||
      object_type == ::worker::detail::ClientComponentVtable::Snapshot) {
    delete static_cast< ::improbable::EntityAcl::Update* >(object);
  } else if (object_type == ::worker::detail::ClientComponentVtable::Request ||
             object_type == ::worker::detail::ClientComponentVtable::Response) {
    delete static_cast< GenericCommandObject_EntityAcl* >(object);
  }
}

::worker::detail::ClientObject* VtableCopy_EntityAcl(
    ::worker::ComponentId, std::uint8_t object_type,
    const ::worker::detail::ClientObject* object) {
  if (object_type == ::worker::detail::ClientComponentVtable::Update ||
      object_type == ::worker::detail::ClientComponentVtable::Snapshot) {
    return new ::improbable::EntityAcl::Update(*static_cast<const ::improbable::EntityAcl::Update*>(object));
  } else if (object_type == ::worker::detail::ClientComponentVtable::Request ||
             object_type == ::worker::detail::ClientComponentVtable::Response) {
    return new GenericCommandObject_EntityAcl(
        *static_cast<const GenericCommandObject_EntityAcl*>(object));
  }
  return nullptr;
}

std::uint8_t VtableDeserialize_EntityAcl(
    ::worker::ComponentId, std::uint8_t object_type, const std::uint8_t* buffer,
    std::uint32_t length, ::worker::detail::ClientObject** object) {
  if (object_type == ::worker::detail::ClientComponentVtable::Update) {
    ::schema::improbable::EntityComponentUpdate proto_wrapper;
    if (!proto_wrapper.ParseFromArray(buffer, length)) {
      return false;
    }
    *object = new ::improbable::EntityAcl::Update;
    auto client_object = static_cast< ::improbable::EntityAcl::Update* >(*object);
    {
      const auto& proto = proto_wrapper.entity_state().GetExtension(::schema::improbable::EntityAcl::component_extension);

      std::set<std::uint32_t> fields_to_clear{proto_wrapper.fields_to_clear().begin(),
                                              proto_wrapper.fields_to_clear().end()};
      if (proto.has_field1_read() || fields_to_clear.count(1)) {
        client_object->read().emplace();
        if (proto.has_field1_read()) {
          client_object->read()->emplace(::improbable::detail::Deserialize_WorkerPredicate(proto.field1_read()));
        }
      }
      if (proto.has_field2_component_acl() || fields_to_clear.count(2)) {
        client_object->component_acl().emplace();
        if (proto.has_field2_component_acl()) {
          client_object->component_acl()->emplace(::improbable::detail::Deserialize_ComponentAcl(proto.field2_component_acl()));
        }
      }
    }
    {
    }
  } else if (object_type == ::worker::detail::ClientComponentVtable::Snapshot) {
    ::schema::improbable::EntityState proto_wrapper;
    if (!proto_wrapper.ParseFromArray(buffer, length)) {
      return false;
    }
    *object = new ::improbable::EntityAcl::Update;
    auto client_object = static_cast< ::improbable::EntityAcl::Update* >(*object);
    const auto& proto = proto_wrapper.GetExtension(::schema::improbable::EntityAcl::component_extension);

    client_object->read().emplace();
    if (proto.has_field1_read()) {
      client_object->read()->emplace(::improbable::detail::Deserialize_WorkerPredicate(proto.field1_read()));
    }
    client_object->component_acl().emplace();
    if (proto.has_field2_component_acl()) {
      client_object->component_acl()->emplace(::improbable::detail::Deserialize_ComponentAcl(proto.field2_component_acl()));
    }
  } else if (object_type == ::worker::detail::ClientComponentVtable::Request) {
    ::schema::improbable::EntityCommand proto_wrapper;
    if (!proto_wrapper.ParseFromArray(buffer, length)) {
      return false;
    }
  } else if (object_type == ::worker::detail::ClientComponentVtable::Response) {
    ::schema::improbable::EntityCommand proto_wrapper;
    if (!proto_wrapper.ParseFromArray(buffer, length)) {
      return false;
    }
  }
  return true;
}

void VtableSerialize_EntityAcl(
    ::worker::ComponentId, std::uint8_t object_type,
    const ::worker::detail::ClientObject* object, std::uint8_t** buffer,
    std::uint32_t* length) {
  static_cast<void>(object);
  if (object_type == ::worker::detail::ClientComponentVtable::Update) {
    ::schema::improbable::EntityComponentUpdate proto_wrapper;
    const auto& data = *static_cast<const ::improbable::EntityAcl::Update*>(object);
    {
      auto& proto = *proto_wrapper.mutable_entity_state()->MutableExtension(::schema::improbable::EntityAcl::component_extension);
      if (data.read()) {
        if (object_type != ::worker::detail::ClientComponentVtable::Snapshot && data.read()->empty()) {
          proto_wrapper.add_fields_to_clear(1);
        }
        if (*data.read()) {
          ::improbable::detail::Serialize_WorkerPredicate(**data.read(), *proto.mutable_field1_read());
        }
      }
      if (data.component_acl()) {
        if (object_type != ::worker::detail::ClientComponentVtable::Snapshot && data.component_acl()->empty()) {
          proto_wrapper.add_fields_to_clear(2);
        }
        if (*data.component_acl()) {
          ::improbable::detail::Serialize_ComponentAcl(**data.component_acl(), *proto.mutable_field2_component_acl());
        }
      }
    }
    {
      proto_wrapper.mutable_entity_event()->MutableExtension(::schema::improbable::EntityAcl::event_extension);
    }

    *length = proto_wrapper.ByteSize();
    *buffer = new std::uint8_t[*length];
    proto_wrapper.SerializeToArray(*buffer, *length);
  } else if (object_type == ::worker::detail::ClientComponentVtable::Snapshot) {
    ::schema::improbable::EntityState proto_wrapper;
    const auto& data = *static_cast<const ::improbable::EntityAcl::Update*>(object);
    auto& proto = *proto_wrapper.MutableExtension(::schema::improbable::EntityAcl::component_extension);

    if (*data.read()) {
      ::improbable::detail::Serialize_WorkerPredicate(**data.read(), *proto.mutable_field1_read());
    }
    if (*data.component_acl()) {
      ::improbable::detail::Serialize_ComponentAcl(**data.component_acl(), *proto.mutable_field2_component_acl());
    }

    *length = proto_wrapper.ByteSize();
    *buffer = new std::uint8_t[*length];
    proto_wrapper.SerializeToArray(*buffer, *length);
  } else if (object_type == ::worker::detail::ClientComponentVtable::Request) {
    ::schema::improbable::EntityCommand proto_wrapper;
    proto_wrapper.MutableExtension(::schema::improbable::EntityAcl::command_extension);


    *length = proto_wrapper.ByteSize();
    *buffer = new std::uint8_t[*length];
    proto_wrapper.SerializeToArray(*buffer, *length);
  } else if (object_type == ::worker::detail::ClientComponentVtable::Response) {
    ::schema::improbable::EntityCommand proto_wrapper;
    proto_wrapper.MutableExtension(::schema::improbable::EntityAcl::command_extension);


    *length = proto_wrapper.ByteSize();
    *buffer = new std::uint8_t[*length];
    proto_wrapper.SerializeToArray(*buffer, *length);
  }
}

}  // anonymous namespace

const ::worker::detail::ClientComponentVtable& Vtable_EntityAcl() {
  static const ::worker::detail::ClientComponentVtable vtable = {
      50,
      &detail::VtableBufferFree_EntityAcl,
      &detail::VtableFree_EntityAcl,
      &detail::VtableCopy_EntityAcl,
      &detail::VtableDeserialize_EntityAcl,
      &detail::VtableSerialize_EntityAcl,
  };
  return vtable;
}

}  // ::detail

}  // ::improbable
